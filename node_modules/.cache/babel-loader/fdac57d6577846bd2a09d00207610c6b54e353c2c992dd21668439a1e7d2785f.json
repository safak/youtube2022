{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FetchHttpClientResponse = exports.FetchHttpClient = void 0;\nconst HttpClient_js_1 = require(\"./HttpClient.js\");\n/**\n * HTTP client which uses a `fetch` function to issue requests.\n *\n * By default relies on the global `fetch` function, but an optional function\n * can be passed in. If passing in a function, it is expected to match the Web\n * Fetch API. As an example, this could be the function provided by the\n * node-fetch package (https://github.com/node-fetch/node-fetch).\n */\nclass FetchHttpClient extends HttpClient_js_1.HttpClient {\n  constructor(fetchFn) {\n    super();\n    this._fetchFn = fetchFn;\n  }\n  /** @override. */\n  getClientName() {\n    return 'fetch';\n  }\n  makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n    const isInsecureConnection = protocol === 'http';\n    const url = new URL(path, `${isInsecureConnection ? 'http' : 'https'}://${host}`);\n    url.port = port;\n    // For methods which expect payloads, we should always pass a body value\n    // even when it is empty. Without this, some JS runtimes (eg. Deno) will\n    // inject a second Content-Length header. See https://github.com/stripe/stripe-node/issues/1519\n    // for more details.\n    const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n    const body = requestData || (methodHasPayload ? '' : undefined);\n    const fetchFn = this._fetchFn || fetch;\n    const fetchPromise = fetchFn(url.toString(), {\n      method,\n      // @ts-ignore\n      headers,\n      // @ts-ignore\n      body\n    });\n    // The Fetch API does not support passing in a timeout natively, so a\n    // timeout promise is constructed to race against the fetch and preempt the\n    // request, simulating a timeout.\n    //\n    // This timeout behavior differs from Node:\n    // - Fetch uses a single timeout for the entire length of the request.\n    // - Node is more fine-grained and resets the timeout after each stage of\n    //   the request.\n    //\n    // As an example, if the timeout is set to 30s and the connection takes 20s\n    // to be established followed by 20s for the body, Fetch would timeout but\n    // Node would not. The more fine-grained timeout cannot be implemented with\n    // fetch.\n    let pendingTimeoutId;\n    const timeoutPromise = new Promise((_, reject) => {\n      pendingTimeoutId = setTimeout(() => {\n        pendingTimeoutId = null;\n        reject(HttpClient_js_1.HttpClient.makeTimeoutError());\n      }, timeout);\n    });\n    return Promise.race([fetchPromise, timeoutPromise]).then(res => {\n      return new FetchHttpClientResponse(res);\n    }).finally(() => {\n      if (pendingTimeoutId) {\n        clearTimeout(pendingTimeoutId);\n      }\n    });\n  }\n}\nexports.FetchHttpClient = FetchHttpClient;\nclass FetchHttpClientResponse extends HttpClient_js_1.HttpClientResponse {\n  constructor(res) {\n    super(res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers));\n    this._res = res;\n  }\n  getRawResponse() {\n    return this._res;\n  }\n  toStream(streamCompleteCallback) {\n    // Unfortunately `fetch` does not have event handlers for when the stream is\n    // completely read. We therefore invoke the streamCompleteCallback right\n    // away. This callback emits a response event with metadata and completes\n    // metrics, so it's ok to do this without waiting for the stream to be\n    // completely read.\n    streamCompleteCallback();\n    // Fetch's `body` property is expected to be a readable stream of the body.\n    return this._res.body;\n  }\n  toJSON() {\n    return this._res.json();\n  }\n  static _transformHeadersToObject(headers) {\n    // Fetch uses a Headers instance so this must be converted to a barebones\n    // JS object to meet the HttpClient interface.\n    const headersObj = {};\n    for (const entry of headers) {\n      if (!Array.isArray(entry) || entry.length != 2) {\n        throw new Error('Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.');\n      }\n      headersObj[entry[0]] = entry[1];\n    }\n    return headersObj;\n  }\n}\nexports.FetchHttpClientResponse = FetchHttpClientResponse;","map":{"version":3,"names":["Object","defineProperty","exports","value","FetchHttpClientResponse","FetchHttpClient","HttpClient_js_1","require","HttpClient","constructor","fetchFn","_fetchFn","getClientName","makeRequest","host","port","path","method","headers","requestData","protocol","timeout","isInsecureConnection","url","URL","methodHasPayload","body","undefined","fetch","fetchPromise","toString","pendingTimeoutId","timeoutPromise","Promise","_","reject","setTimeout","makeTimeoutError","race","then","res","finally","clearTimeout","HttpClientResponse","status","_transformHeadersToObject","_res","getRawResponse","toStream","streamCompleteCallback","toJSON","json","headersObj","entry","Array","isArray","length","Error"],"sources":["C:/Users/Marcia/OneDrive/Escritorio/Web-dev/Working/Ecommerce-2023/client/node_modules/stripe/cjs/net/FetchHttpClient.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FetchHttpClientResponse = exports.FetchHttpClient = void 0;\nconst HttpClient_js_1 = require(\"./HttpClient.js\");\n/**\n * HTTP client which uses a `fetch` function to issue requests.\n *\n * By default relies on the global `fetch` function, but an optional function\n * can be passed in. If passing in a function, it is expected to match the Web\n * Fetch API. As an example, this could be the function provided by the\n * node-fetch package (https://github.com/node-fetch/node-fetch).\n */\nclass FetchHttpClient extends HttpClient_js_1.HttpClient {\n    constructor(fetchFn) {\n        super();\n        this._fetchFn = fetchFn;\n    }\n    /** @override. */\n    getClientName() {\n        return 'fetch';\n    }\n    makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n        const isInsecureConnection = protocol === 'http';\n        const url = new URL(path, `${isInsecureConnection ? 'http' : 'https'}://${host}`);\n        url.port = port;\n        // For methods which expect payloads, we should always pass a body value\n        // even when it is empty. Without this, some JS runtimes (eg. Deno) will\n        // inject a second Content-Length header. See https://github.com/stripe/stripe-node/issues/1519\n        // for more details.\n        const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n        const body = requestData || (methodHasPayload ? '' : undefined);\n        const fetchFn = this._fetchFn || fetch;\n        const fetchPromise = fetchFn(url.toString(), {\n            method,\n            // @ts-ignore\n            headers,\n            // @ts-ignore\n            body,\n        });\n        // The Fetch API does not support passing in a timeout natively, so a\n        // timeout promise is constructed to race against the fetch and preempt the\n        // request, simulating a timeout.\n        //\n        // This timeout behavior differs from Node:\n        // - Fetch uses a single timeout for the entire length of the request.\n        // - Node is more fine-grained and resets the timeout after each stage of\n        //   the request.\n        //\n        // As an example, if the timeout is set to 30s and the connection takes 20s\n        // to be established followed by 20s for the body, Fetch would timeout but\n        // Node would not. The more fine-grained timeout cannot be implemented with\n        // fetch.\n        let pendingTimeoutId;\n        const timeoutPromise = new Promise((_, reject) => {\n            pendingTimeoutId = setTimeout(() => {\n                pendingTimeoutId = null;\n                reject(HttpClient_js_1.HttpClient.makeTimeoutError());\n            }, timeout);\n        });\n        return Promise.race([fetchPromise, timeoutPromise])\n            .then((res) => {\n            return new FetchHttpClientResponse(res);\n        })\n            .finally(() => {\n            if (pendingTimeoutId) {\n                clearTimeout(pendingTimeoutId);\n            }\n        });\n    }\n}\nexports.FetchHttpClient = FetchHttpClient;\nclass FetchHttpClientResponse extends HttpClient_js_1.HttpClientResponse {\n    constructor(res) {\n        super(res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers));\n        this._res = res;\n    }\n    getRawResponse() {\n        return this._res;\n    }\n    toStream(streamCompleteCallback) {\n        // Unfortunately `fetch` does not have event handlers for when the stream is\n        // completely read. We therefore invoke the streamCompleteCallback right\n        // away. This callback emits a response event with metadata and completes\n        // metrics, so it's ok to do this without waiting for the stream to be\n        // completely read.\n        streamCompleteCallback();\n        // Fetch's `body` property is expected to be a readable stream of the body.\n        return this._res.body;\n    }\n    toJSON() {\n        return this._res.json();\n    }\n    static _transformHeadersToObject(headers) {\n        // Fetch uses a Headers instance so this must be converted to a barebones\n        // JS object to meet the HttpClient interface.\n        const headersObj = {};\n        for (const entry of headers) {\n            if (!Array.isArray(entry) || entry.length != 2) {\n                throw new Error('Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.');\n            }\n            headersObj[entry[0]] = entry[1];\n        }\n        return headersObj;\n    }\n}\nexports.FetchHttpClientResponse = FetchHttpClientResponse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}