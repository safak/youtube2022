{"ast":null,"code":"import { StripeAPIError, StripeAuthenticationError, StripeConnectionError, StripeError, StripePermissionError, StripeRateLimitError } from './Error.js';\nimport { emitWarning, normalizeHeaders, removeNullish, stringifyRequestData } from './utils.js';\nimport { HttpClient } from './net/HttpClient.js';\nconst MAX_RETRY_AFTER_WAIT = 60;\nexport class RequestSender {\n  constructor(stripe, maxBufferedRequestMetric) {\n    this._stripe = stripe;\n    this._maxBufferedRequestMetric = maxBufferedRequestMetric;\n  }\n  _addHeadersDirectlyToObject(obj, headers) {\n    // For convenience, make some headers easily accessible on\n    // lastResponse.\n    // NOTE: Stripe responds with lowercase header names/keys.\n    obj.requestId = headers['request-id'];\n    obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];\n    obj.apiVersion = obj.apiVersion || headers['stripe-version'];\n    obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];\n  }\n  _makeResponseEvent(requestEvent, statusCode, headers) {\n    const requestEndTime = Date.now();\n    const requestDurationMs = requestEndTime - requestEvent.request_start_time;\n    return removeNullish({\n      api_version: headers['stripe-version'],\n      account: headers['stripe-account'],\n      idempotency_key: headers['idempotency-key'],\n      method: requestEvent.method,\n      path: requestEvent.path,\n      status: statusCode,\n      request_id: this._getRequestId(headers),\n      elapsed: requestDurationMs,\n      request_start_time: requestEvent.request_start_time,\n      request_end_time: requestEndTime\n    });\n  }\n  _getRequestId(headers) {\n    return headers['request-id'];\n  }\n  /**\n   * Used by methods with spec.streaming === true. For these methods, we do not\n   * buffer successful responses into memory or do parse them into stripe\n   * objects, we delegate that all of that to the user and pass back the raw\n   * http.Response object to the callback.\n   *\n   * (Unsuccessful responses shouldn't make it here, they should\n   * still be buffered/parsed and handled by _jsonResponseHandler -- see\n   * makeRequest)\n   */\n  _streamingResponseHandler(requestEvent, callback) {\n    return res => {\n      const headers = res.getHeaders();\n      const streamCompleteCallback = () => {\n        const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);\n        this._stripe._emitter.emit('response', responseEvent);\n        this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed);\n      };\n      const stream = res.toStream(streamCompleteCallback);\n      // This is here for backwards compatibility, as the stream is a raw\n      // HTTP response in Node and the legacy behavior was to mutate this\n      // response.\n      this._addHeadersDirectlyToObject(stream, headers);\n      return callback(null, stream);\n    };\n  }\n  /**\n   * Default handler for Stripe responses. Buffers the response into memory,\n   * parses the JSON and returns it (i.e. passes it to the callback) if there\n   * is no \"error\" field. Otherwise constructs/passes an appropriate Error.\n   */\n  _jsonResponseHandler(requestEvent, callback) {\n    return res => {\n      const headers = res.getHeaders();\n      const requestId = this._getRequestId(headers);\n      const statusCode = res.getStatusCode();\n      const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);\n      this._stripe._emitter.emit('response', responseEvent);\n      res.toJSON().then(jsonResponse => {\n        if (jsonResponse.error) {\n          let err;\n          // Convert OAuth error responses into a standard format\n          // so that the rest of the error logic can be shared\n          if (typeof jsonResponse.error === 'string') {\n            jsonResponse.error = {\n              type: jsonResponse.error,\n              message: jsonResponse.error_description\n            };\n          }\n          jsonResponse.error.headers = headers;\n          jsonResponse.error.statusCode = statusCode;\n          jsonResponse.error.requestId = requestId;\n          if (statusCode === 401) {\n            err = new StripeAuthenticationError(jsonResponse.error);\n          } else if (statusCode === 403) {\n            err = new StripePermissionError(jsonResponse.error);\n          } else if (statusCode === 429) {\n            err = new StripeRateLimitError(jsonResponse.error);\n          } else {\n            err = StripeError.generate(jsonResponse.error);\n          }\n          throw err;\n        }\n        return jsonResponse;\n      }, e => {\n        throw new StripeAPIError({\n          message: 'Invalid JSON received from the Stripe API',\n          exception: e,\n          requestId: headers['request-id']\n        });\n      }).then(jsonResponse => {\n        this._recordRequestMetrics(requestId, responseEvent.elapsed);\n        // Expose raw response object.\n        const rawResponse = res.getRawResponse();\n        this._addHeadersDirectlyToObject(rawResponse, headers);\n        Object.defineProperty(jsonResponse, 'lastResponse', {\n          enumerable: false,\n          writable: false,\n          value: rawResponse\n        });\n        callback(null, jsonResponse);\n      }, e => callback(e, null));\n    };\n  }\n  static _generateConnectionErrorMessage(requestRetries) {\n    return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ''}`;\n  }\n  // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency\n  static _shouldRetry(res, numRetries, maxRetries, error) {\n    if (error && numRetries === 0 && HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {\n      return true;\n    }\n    // Do not retry if we are out of retries.\n    if (numRetries >= maxRetries) {\n      return false;\n    }\n    // Retry on connection error.\n    if (!res) {\n      return true;\n    }\n    // The API may ask us not to retry (e.g., if doing so would be a no-op)\n    // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.\n    if (res.getHeaders()['stripe-should-retry'] === 'false') {\n      return false;\n    }\n    if (res.getHeaders()['stripe-should-retry'] === 'true') {\n      return true;\n    }\n    // Retry on conflict errors.\n    if (res.getStatusCode() === 409) {\n      return true;\n    }\n    // Retry on 500, 503, and other internal errors.\n    //\n    // Note that we expect the stripe-should-retry header to be false\n    // in most cases when a 500 is returned, since our idempotency framework\n    // would typically replay it anyway.\n    if (res.getStatusCode() >= 500) {\n      return true;\n    }\n    return false;\n  }\n  _getSleepTimeInMS(numRetries) {\n    let retryAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();\n    const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();\n    // Apply exponential backoff with initialNetworkRetryDelay on the\n    // number of numRetries so far as inputs. Do not allow the number to exceed\n    // maxNetworkRetryDelay.\n    let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(numRetries - 1, 2), maxNetworkRetryDelay);\n    // Apply some jitter by randomizing the value in the range of\n    // (sleepSeconds / 2) to (sleepSeconds).\n    sleepSeconds *= 0.5 * (1 + Math.random());\n    // But never sleep less than the base sleep seconds.\n    sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);\n    // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n    if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {\n      sleepSeconds = Math.max(sleepSeconds, retryAfter);\n    }\n    return sleepSeconds * 1000;\n  }\n  // Max retries can be set on a per request basis. Favor those over the global setting\n  _getMaxNetworkRetries() {\n    let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return settings.maxNetworkRetries !== undefined && Number.isInteger(settings.maxNetworkRetries) ? settings.maxNetworkRetries : this._stripe.getMaxNetworkRetries();\n  }\n  _defaultIdempotencyKey(method, settings) {\n    // If this is a POST and we allow multiple retries, ensure an idempotency key.\n    const maxRetries = this._getMaxNetworkRetries(settings);\n    if (method === 'POST' && maxRetries > 0) {\n      return `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`;\n    }\n    return null;\n  }\n  _makeHeaders(auth, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings) {\n    const defaultHeaders = {\n      // Use specified auth token or use default from this stripe instance:\n      Authorization: auth ? `Bearer ${auth}` : this._stripe.getApiField('auth'),\n      Accept: 'application/json',\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'User-Agent': this._getUserAgentString(),\n      'X-Stripe-Client-User-Agent': clientUserAgent,\n      'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),\n      'Stripe-Version': apiVersion,\n      'Stripe-Account': this._stripe.getApiField('stripeAccount'),\n      'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings)\n    };\n    // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:\n    //   A user agent SHOULD send a Content-Length in a request message when\n    //   no Transfer-Encoding is sent and the request method defines a meaning\n    //   for an enclosed payload body.  For example, a Content-Length header\n    //   field is normally sent in a POST request even when the value is 0\n    //   (indicating an empty payload body).  A user agent SHOULD NOT send a\n    //   Content-Length header field when the request message does not contain\n    //   a payload body and the method semantics do not anticipate such a\n    //   body.\n    //\n    // These method types are expected to have bodies and so we should always\n    // include a Content-Length.\n    const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n    // If a content length was specified, we always include it regardless of\n    // whether the method semantics anticipate such a body. This keeps us\n    // consistent with historical behavior. We do however want to warn on this\n    // and fix these cases as they are semantically incorrect.\n    if (methodHasPayload || contentLength) {\n      if (!methodHasPayload) {\n        emitWarning(`${method} method had non-zero contentLength but no payload is expected for this verb`);\n      }\n      defaultHeaders['Content-Length'] = contentLength;\n    }\n    return Object.assign(removeNullish(defaultHeaders),\n    // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.\n    normalizeHeaders(userSuppliedHeaders));\n  }\n  _getUserAgentString() {\n    const packageVersion = this._stripe.getConstant('PACKAGE_VERSION');\n    const appInfo = this._stripe._appInfo ? this._stripe.getAppInfoAsString() : '';\n    return `Stripe/v1 NodeBindings/${packageVersion} ${appInfo}`.trim();\n  }\n  _getTelemetryHeader() {\n    if (this._stripe.getTelemetryEnabled() && this._stripe._prevRequestMetrics.length > 0) {\n      const metrics = this._stripe._prevRequestMetrics.shift();\n      return JSON.stringify({\n        last_request_metrics: metrics\n      });\n    }\n  }\n  _recordRequestMetrics(requestId, requestDurationMs) {\n    if (this._stripe.getTelemetryEnabled() && requestId) {\n      if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {\n        emitWarning('Request metrics buffer is full, dropping telemetry message.');\n      } else {\n        this._stripe._prevRequestMetrics.push({\n          request_id: requestId,\n          request_duration_ms: requestDurationMs\n        });\n      }\n    }\n  }\n  _request(method, host, path, data, auth) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    let callback = arguments.length > 6 ? arguments[6] : undefined;\n    let requestDataProcessor = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    let requestData;\n    const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {\n      return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);\n    };\n    const makeRequest = (apiVersion, headers, numRetries) => {\n      // timeout can be set on a per-request basis. Favor that over the global setting\n      const timeout = options.settings && options.settings.timeout && Number.isInteger(options.settings.timeout) && options.settings.timeout >= 0 ? options.settings.timeout : this._stripe.getApiField('timeout');\n      const req = this._stripe.getApiField('httpClient').makeRequest(host || this._stripe.getApiField('host'), this._stripe.getApiField('port'), path, method, headers, requestData, this._stripe.getApiField('protocol'), timeout);\n      const requestStartTime = Date.now();\n      // @ts-ignore\n      const requestEvent = removeNullish({\n        api_version: apiVersion,\n        account: headers['Stripe-Account'],\n        idempotency_key: headers['Idempotency-Key'],\n        method,\n        path,\n        request_start_time: requestStartTime\n      });\n      const requestRetries = numRetries || 0;\n      const maxRetries = this._getMaxNetworkRetries(options.settings || {});\n      this._stripe._emitter.emit('request', requestEvent);\n      req.then(res => {\n        if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {\n          return retryRequest(makeRequest, apiVersion, headers, requestRetries,\n          // @ts-ignore\n          res.getHeaders()['retry-after']);\n        } else if (options.streaming && res.getStatusCode() < 400) {\n          return this._streamingResponseHandler(requestEvent, callback)(res);\n        } else {\n          return this._jsonResponseHandler(requestEvent, callback)(res);\n        }\n      }).catch(error => {\n        if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {\n          return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);\n        } else {\n          const isTimeoutError = error.code && error.code === HttpClient.TIMEOUT_ERROR_CODE;\n          return callback(new StripeConnectionError({\n            message: isTimeoutError ? `Request aborted due to timeout being reached (${timeout}ms)` : RequestSender._generateConnectionErrorMessage(requestRetries),\n            // @ts-ignore\n            detail: error\n          }));\n        }\n      });\n    };\n    const prepareAndMakeRequest = (error, data) => {\n      if (error) {\n        return callback(error);\n      }\n      requestData = data;\n      this._stripe.getClientUserAgent(clientUserAgent => {\n        var _a, _b;\n        const apiVersion = this._stripe.getApiField('version');\n        const headers = this._makeHeaders(auth, requestData.length, apiVersion, clientUserAgent, method, (_a = options.headers) !== null && _a !== void 0 ? _a : null, (_b = options.settings) !== null && _b !== void 0 ? _b : {});\n        makeRequest(apiVersion, headers, 0);\n      });\n    };\n    if (requestDataProcessor) {\n      requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);\n    } else {\n      prepareAndMakeRequest(null, stringifyRequestData(data || {}));\n    }\n  }\n}","map":{"version":3,"names":["StripeAPIError","StripeAuthenticationError","StripeConnectionError","StripeError","StripePermissionError","StripeRateLimitError","emitWarning","normalizeHeaders","removeNullish","stringifyRequestData","HttpClient","MAX_RETRY_AFTER_WAIT","RequestSender","constructor","stripe","maxBufferedRequestMetric","_stripe","_maxBufferedRequestMetric","_addHeadersDirectlyToObject","obj","headers","requestId","stripeAccount","apiVersion","idempotencyKey","_makeResponseEvent","requestEvent","statusCode","requestEndTime","Date","now","requestDurationMs","request_start_time","api_version","account","idempotency_key","method","path","status","request_id","_getRequestId","elapsed","request_end_time","_streamingResponseHandler","callback","res","getHeaders","streamCompleteCallback","responseEvent","getStatusCode","_emitter","emit","_recordRequestMetrics","stream","toStream","_jsonResponseHandler","toJSON","then","jsonResponse","error","err","type","message","error_description","generate","e","exception","rawResponse","getRawResponse","Object","defineProperty","enumerable","writable","value","_generateConnectionErrorMessage","requestRetries","_shouldRetry","numRetries","maxRetries","CONNECTION_CLOSED_ERROR_CODES","includes","code","_getSleepTimeInMS","retryAfter","arguments","length","undefined","initialNetworkRetryDelay","getInitialNetworkRetryDelay","maxNetworkRetryDelay","getMaxNetworkRetryDelay","sleepSeconds","Math","min","pow","random","max","Number","isInteger","_getMaxNetworkRetries","settings","maxNetworkRetries","getMaxNetworkRetries","_defaultIdempotencyKey","_platformFunctions","uuid4","_makeHeaders","auth","contentLength","clientUserAgent","userSuppliedHeaders","userSuppliedSettings","defaultHeaders","Authorization","getApiField","Accept","_getUserAgentString","_getTelemetryHeader","methodHasPayload","assign","packageVersion","getConstant","appInfo","_appInfo","getAppInfoAsString","trim","getTelemetryEnabled","_prevRequestMetrics","metrics","shift","JSON","stringify","last_request_metrics","push","request_duration_ms","_request","host","data","options","requestDataProcessor","requestData","retryRequest","requestFn","setTimeout","makeRequest","timeout","req","requestStartTime","streaming","catch","isTimeoutError","TIMEOUT_ERROR_CODE","detail","prepareAndMakeRequest","getClientUserAgent","_a","_b"],"sources":["C:/Users/Marcia/OneDrive/Escritorio/Web-dev/Working/Ecommerce-2023/client/node_modules/stripe/esm/RequestSender.js"],"sourcesContent":["import { StripeAPIError, StripeAuthenticationError, StripeConnectionError, StripeError, StripePermissionError, StripeRateLimitError, } from './Error.js';\nimport { emitWarning, normalizeHeaders, removeNullish, stringifyRequestData, } from './utils.js';\nimport { HttpClient } from './net/HttpClient.js';\nconst MAX_RETRY_AFTER_WAIT = 60;\nexport class RequestSender {\n    constructor(stripe, maxBufferedRequestMetric) {\n        this._stripe = stripe;\n        this._maxBufferedRequestMetric = maxBufferedRequestMetric;\n    }\n    _addHeadersDirectlyToObject(obj, headers) {\n        // For convenience, make some headers easily accessible on\n        // lastResponse.\n        // NOTE: Stripe responds with lowercase header names/keys.\n        obj.requestId = headers['request-id'];\n        obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];\n        obj.apiVersion = obj.apiVersion || headers['stripe-version'];\n        obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];\n    }\n    _makeResponseEvent(requestEvent, statusCode, headers) {\n        const requestEndTime = Date.now();\n        const requestDurationMs = requestEndTime - requestEvent.request_start_time;\n        return removeNullish({\n            api_version: headers['stripe-version'],\n            account: headers['stripe-account'],\n            idempotency_key: headers['idempotency-key'],\n            method: requestEvent.method,\n            path: requestEvent.path,\n            status: statusCode,\n            request_id: this._getRequestId(headers),\n            elapsed: requestDurationMs,\n            request_start_time: requestEvent.request_start_time,\n            request_end_time: requestEndTime,\n        });\n    }\n    _getRequestId(headers) {\n        return headers['request-id'];\n    }\n    /**\n     * Used by methods with spec.streaming === true. For these methods, we do not\n     * buffer successful responses into memory or do parse them into stripe\n     * objects, we delegate that all of that to the user and pass back the raw\n     * http.Response object to the callback.\n     *\n     * (Unsuccessful responses shouldn't make it here, they should\n     * still be buffered/parsed and handled by _jsonResponseHandler -- see\n     * makeRequest)\n     */\n    _streamingResponseHandler(requestEvent, callback) {\n        return (res) => {\n            const headers = res.getHeaders();\n            const streamCompleteCallback = () => {\n                const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);\n                this._stripe._emitter.emit('response', responseEvent);\n                this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed);\n            };\n            const stream = res.toStream(streamCompleteCallback);\n            // This is here for backwards compatibility, as the stream is a raw\n            // HTTP response in Node and the legacy behavior was to mutate this\n            // response.\n            this._addHeadersDirectlyToObject(stream, headers);\n            return callback(null, stream);\n        };\n    }\n    /**\n     * Default handler for Stripe responses. Buffers the response into memory,\n     * parses the JSON and returns it (i.e. passes it to the callback) if there\n     * is no \"error\" field. Otherwise constructs/passes an appropriate Error.\n     */\n    _jsonResponseHandler(requestEvent, callback) {\n        return (res) => {\n            const headers = res.getHeaders();\n            const requestId = this._getRequestId(headers);\n            const statusCode = res.getStatusCode();\n            const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);\n            this._stripe._emitter.emit('response', responseEvent);\n            res\n                .toJSON()\n                .then((jsonResponse) => {\n                if (jsonResponse.error) {\n                    let err;\n                    // Convert OAuth error responses into a standard format\n                    // so that the rest of the error logic can be shared\n                    if (typeof jsonResponse.error === 'string') {\n                        jsonResponse.error = {\n                            type: jsonResponse.error,\n                            message: jsonResponse.error_description,\n                        };\n                    }\n                    jsonResponse.error.headers = headers;\n                    jsonResponse.error.statusCode = statusCode;\n                    jsonResponse.error.requestId = requestId;\n                    if (statusCode === 401) {\n                        err = new StripeAuthenticationError(jsonResponse.error);\n                    }\n                    else if (statusCode === 403) {\n                        err = new StripePermissionError(jsonResponse.error);\n                    }\n                    else if (statusCode === 429) {\n                        err = new StripeRateLimitError(jsonResponse.error);\n                    }\n                    else {\n                        err = StripeError.generate(jsonResponse.error);\n                    }\n                    throw err;\n                }\n                return jsonResponse;\n            }, (e) => {\n                throw new StripeAPIError({\n                    message: 'Invalid JSON received from the Stripe API',\n                    exception: e,\n                    requestId: headers['request-id'],\n                });\n            })\n                .then((jsonResponse) => {\n                this._recordRequestMetrics(requestId, responseEvent.elapsed);\n                // Expose raw response object.\n                const rawResponse = res.getRawResponse();\n                this._addHeadersDirectlyToObject(rawResponse, headers);\n                Object.defineProperty(jsonResponse, 'lastResponse', {\n                    enumerable: false,\n                    writable: false,\n                    value: rawResponse,\n                });\n                callback(null, jsonResponse);\n            }, (e) => callback(e, null));\n        };\n    }\n    static _generateConnectionErrorMessage(requestRetries) {\n        return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ''}`;\n    }\n    // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency\n    static _shouldRetry(res, numRetries, maxRetries, error) {\n        if (error &&\n            numRetries === 0 &&\n            HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {\n            return true;\n        }\n        // Do not retry if we are out of retries.\n        if (numRetries >= maxRetries) {\n            return false;\n        }\n        // Retry on connection error.\n        if (!res) {\n            return true;\n        }\n        // The API may ask us not to retry (e.g., if doing so would be a no-op)\n        // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.\n        if (res.getHeaders()['stripe-should-retry'] === 'false') {\n            return false;\n        }\n        if (res.getHeaders()['stripe-should-retry'] === 'true') {\n            return true;\n        }\n        // Retry on conflict errors.\n        if (res.getStatusCode() === 409) {\n            return true;\n        }\n        // Retry on 500, 503, and other internal errors.\n        //\n        // Note that we expect the stripe-should-retry header to be false\n        // in most cases when a 500 is returned, since our idempotency framework\n        // would typically replay it anyway.\n        if (res.getStatusCode() >= 500) {\n            return true;\n        }\n        return false;\n    }\n    _getSleepTimeInMS(numRetries, retryAfter = null) {\n        const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();\n        const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();\n        // Apply exponential backoff with initialNetworkRetryDelay on the\n        // number of numRetries so far as inputs. Do not allow the number to exceed\n        // maxNetworkRetryDelay.\n        let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(numRetries - 1, 2), maxNetworkRetryDelay);\n        // Apply some jitter by randomizing the value in the range of\n        // (sleepSeconds / 2) to (sleepSeconds).\n        sleepSeconds *= 0.5 * (1 + Math.random());\n        // But never sleep less than the base sleep seconds.\n        sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);\n        // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n        if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {\n            sleepSeconds = Math.max(sleepSeconds, retryAfter);\n        }\n        return sleepSeconds * 1000;\n    }\n    // Max retries can be set on a per request basis. Favor those over the global setting\n    _getMaxNetworkRetries(settings = {}) {\n        return settings.maxNetworkRetries !== undefined &&\n            Number.isInteger(settings.maxNetworkRetries)\n            ? settings.maxNetworkRetries\n            : this._stripe.getMaxNetworkRetries();\n    }\n    _defaultIdempotencyKey(method, settings) {\n        // If this is a POST and we allow multiple retries, ensure an idempotency key.\n        const maxRetries = this._getMaxNetworkRetries(settings);\n        if (method === 'POST' && maxRetries > 0) {\n            return `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`;\n        }\n        return null;\n    }\n    _makeHeaders(auth, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings) {\n        const defaultHeaders = {\n            // Use specified auth token or use default from this stripe instance:\n            Authorization: auth ? `Bearer ${auth}` : this._stripe.getApiField('auth'),\n            Accept: 'application/json',\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'User-Agent': this._getUserAgentString(),\n            'X-Stripe-Client-User-Agent': clientUserAgent,\n            'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),\n            'Stripe-Version': apiVersion,\n            'Stripe-Account': this._stripe.getApiField('stripeAccount'),\n            'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings),\n        };\n        // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:\n        //   A user agent SHOULD send a Content-Length in a request message when\n        //   no Transfer-Encoding is sent and the request method defines a meaning\n        //   for an enclosed payload body.  For example, a Content-Length header\n        //   field is normally sent in a POST request even when the value is 0\n        //   (indicating an empty payload body).  A user agent SHOULD NOT send a\n        //   Content-Length header field when the request message does not contain\n        //   a payload body and the method semantics do not anticipate such a\n        //   body.\n        //\n        // These method types are expected to have bodies and so we should always\n        // include a Content-Length.\n        const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n        // If a content length was specified, we always include it regardless of\n        // whether the method semantics anticipate such a body. This keeps us\n        // consistent with historical behavior. We do however want to warn on this\n        // and fix these cases as they are semantically incorrect.\n        if (methodHasPayload || contentLength) {\n            if (!methodHasPayload) {\n                emitWarning(`${method} method had non-zero contentLength but no payload is expected for this verb`);\n            }\n            defaultHeaders['Content-Length'] = contentLength;\n        }\n        return Object.assign(removeNullish(defaultHeaders), \n        // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.\n        normalizeHeaders(userSuppliedHeaders));\n    }\n    _getUserAgentString() {\n        const packageVersion = this._stripe.getConstant('PACKAGE_VERSION');\n        const appInfo = this._stripe._appInfo\n            ? this._stripe.getAppInfoAsString()\n            : '';\n        return `Stripe/v1 NodeBindings/${packageVersion} ${appInfo}`.trim();\n    }\n    _getTelemetryHeader() {\n        if (this._stripe.getTelemetryEnabled() &&\n            this._stripe._prevRequestMetrics.length > 0) {\n            const metrics = this._stripe._prevRequestMetrics.shift();\n            return JSON.stringify({\n                last_request_metrics: metrics,\n            });\n        }\n    }\n    _recordRequestMetrics(requestId, requestDurationMs) {\n        if (this._stripe.getTelemetryEnabled() && requestId) {\n            if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {\n                emitWarning('Request metrics buffer is full, dropping telemetry message.');\n            }\n            else {\n                this._stripe._prevRequestMetrics.push({\n                    request_id: requestId,\n                    request_duration_ms: requestDurationMs,\n                });\n            }\n        }\n    }\n    _request(method, host, path, data, auth, options = {}, callback, requestDataProcessor = null) {\n        let requestData;\n        const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {\n            return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);\n        };\n        const makeRequest = (apiVersion, headers, numRetries) => {\n            // timeout can be set on a per-request basis. Favor that over the global setting\n            const timeout = options.settings &&\n                options.settings.timeout &&\n                Number.isInteger(options.settings.timeout) &&\n                options.settings.timeout >= 0\n                ? options.settings.timeout\n                : this._stripe.getApiField('timeout');\n            const req = this._stripe\n                .getApiField('httpClient')\n                .makeRequest(host || this._stripe.getApiField('host'), this._stripe.getApiField('port'), path, method, headers, requestData, this._stripe.getApiField('protocol'), timeout);\n            const requestStartTime = Date.now();\n            // @ts-ignore\n            const requestEvent = removeNullish({\n                api_version: apiVersion,\n                account: headers['Stripe-Account'],\n                idempotency_key: headers['Idempotency-Key'],\n                method,\n                path,\n                request_start_time: requestStartTime,\n            });\n            const requestRetries = numRetries || 0;\n            const maxRetries = this._getMaxNetworkRetries(options.settings || {});\n            this._stripe._emitter.emit('request', requestEvent);\n            req\n                .then((res) => {\n                if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {\n                    return retryRequest(makeRequest, apiVersion, headers, requestRetries, \n                    // @ts-ignore\n                    res.getHeaders()['retry-after']);\n                }\n                else if (options.streaming && res.getStatusCode() < 400) {\n                    return this._streamingResponseHandler(requestEvent, callback)(res);\n                }\n                else {\n                    return this._jsonResponseHandler(requestEvent, callback)(res);\n                }\n            })\n                .catch((error) => {\n                if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {\n                    return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);\n                }\n                else {\n                    const isTimeoutError = error.code && error.code === HttpClient.TIMEOUT_ERROR_CODE;\n                    return callback(new StripeConnectionError({\n                        message: isTimeoutError\n                            ? `Request aborted due to timeout being reached (${timeout}ms)`\n                            : RequestSender._generateConnectionErrorMessage(requestRetries),\n                        // @ts-ignore\n                        detail: error,\n                    }));\n                }\n            });\n        };\n        const prepareAndMakeRequest = (error, data) => {\n            if (error) {\n                return callback(error);\n            }\n            requestData = data;\n            this._stripe.getClientUserAgent((clientUserAgent) => {\n                var _a, _b;\n                const apiVersion = this._stripe.getApiField('version');\n                const headers = this._makeHeaders(auth, requestData.length, apiVersion, clientUserAgent, method, (_a = options.headers) !== null && _a !== void 0 ? _a : null, (_b = options.settings) !== null && _b !== void 0 ? _b : {});\n                makeRequest(apiVersion, headers, 0);\n            });\n        };\n        if (requestDataProcessor) {\n            requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);\n        }\n        else {\n            prepareAndMakeRequest(null, stringifyRequestData(data || {}));\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}