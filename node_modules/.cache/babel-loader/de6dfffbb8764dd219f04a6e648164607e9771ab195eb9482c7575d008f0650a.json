{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SubtleCryptoProvider = void 0;\nconst CryptoProvider_js_1 = require(\"./CryptoProvider.js\");\n/**\n * `CryptoProvider which uses the SubtleCrypto interface of the Web Crypto API.\n *\n * This only supports asynchronous operations.\n */\nclass SubtleCryptoProvider extends CryptoProvider_js_1.CryptoProvider {\n  constructor(subtleCrypto) {\n    super();\n    // If no subtle crypto is interface, default to the global namespace. This\n    // is to allow custom interfaces (eg. using the Node webcrypto interface in\n    // tests).\n    this.subtleCrypto = subtleCrypto || crypto.subtle;\n  }\n  /** @override */\n  computeHMACSignature(payload, secret) {\n    throw new CryptoProvider_js_1.CryptoProviderOnlySupportsAsyncError('SubtleCryptoProvider cannot be used in a synchronous context.');\n  }\n  /** @override */\n  async computeHMACSignatureAsync(payload, secret) {\n    const encoder = new TextEncoder();\n    const key = await this.subtleCrypto.importKey('raw', encoder.encode(secret), {\n      name: 'HMAC',\n      hash: {\n        name: 'SHA-256'\n      }\n    }, false, ['sign']);\n    const signatureBuffer = await this.subtleCrypto.sign('hmac', key, encoder.encode(payload));\n    // crypto.subtle returns the signature in base64 format. This must be\n    // encoded in hex to match the CryptoProvider contract. We map each byte in\n    // the buffer to its corresponding hex octet and then combine into a string.\n    const signatureBytes = new Uint8Array(signatureBuffer);\n    const signatureHexCodes = new Array(signatureBytes.length);\n    for (let i = 0; i < signatureBytes.length; i++) {\n      signatureHexCodes[i] = byteHexMapping[signatureBytes[i]];\n    }\n    return signatureHexCodes.join('');\n  }\n}\nexports.SubtleCryptoProvider = SubtleCryptoProvider;\n// Cached mapping of byte to hex representation. We do this once to avoid re-\n// computing every time we need to convert the result of a signature to hex.\nconst byteHexMapping = new Array(256);\nfor (let i = 0; i < byteHexMapping.length; i++) {\n  byteHexMapping[i] = i.toString(16).padStart(2, '0');\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","SubtleCryptoProvider","CryptoProvider_js_1","require","CryptoProvider","constructor","subtleCrypto","crypto","subtle","computeHMACSignature","payload","secret","CryptoProviderOnlySupportsAsyncError","computeHMACSignatureAsync","encoder","TextEncoder","key","importKey","encode","name","hash","signatureBuffer","sign","signatureBytes","Uint8Array","signatureHexCodes","Array","length","i","byteHexMapping","join","toString","padStart"],"sources":["C:/Users/Marcia/OneDrive/Escritorio/Web-dev/Working/Ecommerce-2023/client/node_modules/stripe/cjs/crypto/SubtleCryptoProvider.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SubtleCryptoProvider = void 0;\nconst CryptoProvider_js_1 = require(\"./CryptoProvider.js\");\n/**\n * `CryptoProvider which uses the SubtleCrypto interface of the Web Crypto API.\n *\n * This only supports asynchronous operations.\n */\nclass SubtleCryptoProvider extends CryptoProvider_js_1.CryptoProvider {\n    constructor(subtleCrypto) {\n        super();\n        // If no subtle crypto is interface, default to the global namespace. This\n        // is to allow custom interfaces (eg. using the Node webcrypto interface in\n        // tests).\n        this.subtleCrypto = subtleCrypto || crypto.subtle;\n    }\n    /** @override */\n    computeHMACSignature(payload, secret) {\n        throw new CryptoProvider_js_1.CryptoProviderOnlySupportsAsyncError('SubtleCryptoProvider cannot be used in a synchronous context.');\n    }\n    /** @override */\n    async computeHMACSignatureAsync(payload, secret) {\n        const encoder = new TextEncoder();\n        const key = await this.subtleCrypto.importKey('raw', encoder.encode(secret), {\n            name: 'HMAC',\n            hash: { name: 'SHA-256' },\n        }, false, ['sign']);\n        const signatureBuffer = await this.subtleCrypto.sign('hmac', key, encoder.encode(payload));\n        // crypto.subtle returns the signature in base64 format. This must be\n        // encoded in hex to match the CryptoProvider contract. We map each byte in\n        // the buffer to its corresponding hex octet and then combine into a string.\n        const signatureBytes = new Uint8Array(signatureBuffer);\n        const signatureHexCodes = new Array(signatureBytes.length);\n        for (let i = 0; i < signatureBytes.length; i++) {\n            signatureHexCodes[i] = byteHexMapping[signatureBytes[i]];\n        }\n        return signatureHexCodes.join('');\n    }\n}\nexports.SubtleCryptoProvider = SubtleCryptoProvider;\n// Cached mapping of byte to hex representation. We do this once to avoid re-\n// computing every time we need to convert the result of a signature to hex.\nconst byteHexMapping = new Array(256);\nfor (let i = 0; i < byteHexMapping.length; i++) {\n    byteHexMapping[i] = i.toString(16).padStart(2, '0');\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,oBAAoB,GAAG,KAAK,CAAC;AACrC,MAAMC,mBAAmB,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AAC1D;AACA;AACA;AACA;AACA;AACA,MAAMF,oBAAoB,SAASC,mBAAmB,CAACE,cAAc,CAAC;EAClEC,WAAWA,CAACC,YAAY,EAAE;IACtB,KAAK,EAAE;IACP;IACA;IACA;IACA,IAAI,CAACA,YAAY,GAAGA,YAAY,IAAIC,MAAM,CAACC,MAAM;EACrD;EACA;EACAC,oBAAoBA,CAACC,OAAO,EAAEC,MAAM,EAAE;IAClC,MAAM,IAAIT,mBAAmB,CAACU,oCAAoC,CAAC,+DAA+D,CAAC;EACvI;EACA;EACA,MAAMC,yBAAyBA,CAACH,OAAO,EAAEC,MAAM,EAAE;IAC7C,MAAMG,OAAO,GAAG,IAAIC,WAAW,EAAE;IACjC,MAAMC,GAAG,GAAG,MAAM,IAAI,CAACV,YAAY,CAACW,SAAS,CAAC,KAAK,EAAEH,OAAO,CAACI,MAAM,CAACP,MAAM,CAAC,EAAE;MACzEQ,IAAI,EAAE,MAAM;MACZC,IAAI,EAAE;QAAED,IAAI,EAAE;MAAU;IAC5B,CAAC,EAAE,KAAK,EAAE,CAAC,MAAM,CAAC,CAAC;IACnB,MAAME,eAAe,GAAG,MAAM,IAAI,CAACf,YAAY,CAACgB,IAAI,CAAC,MAAM,EAAEN,GAAG,EAAEF,OAAO,CAACI,MAAM,CAACR,OAAO,CAAC,CAAC;IAC1F;IACA;IACA;IACA,MAAMa,cAAc,GAAG,IAAIC,UAAU,CAACH,eAAe,CAAC;IACtD,MAAMI,iBAAiB,GAAG,IAAIC,KAAK,CAACH,cAAc,CAACI,MAAM,CAAC;IAC1D,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,cAAc,CAACI,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC5CH,iBAAiB,CAACG,CAAC,CAAC,GAAGC,cAAc,CAACN,cAAc,CAACK,CAAC,CAAC,CAAC;IAC5D;IACA,OAAOH,iBAAiB,CAACK,IAAI,CAAC,EAAE,CAAC;EACrC;AACJ;AACA/B,OAAO,CAACE,oBAAoB,GAAGA,oBAAoB;AACnD;AACA;AACA,MAAM4B,cAAc,GAAG,IAAIH,KAAK,CAAC,GAAG,CAAC;AACrC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,cAAc,CAACF,MAAM,EAAEC,CAAC,EAAE,EAAE;EAC5CC,cAAc,CAACD,CAAC,CAAC,GAAGA,CAAC,CAACG,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;AACvD"},"metadata":{},"sourceType":"script","externalDependencies":[]}