{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeAutoPaginationMethods = void 0;\nconst utils_js_1 = require(\"./utils.js\");\nclass StripeIterator {\n  constructor(firstPagePromise, requestArgs, spec, stripeResource) {\n    this.index = 0;\n    this.pagePromise = firstPagePromise;\n    this.promiseCache = {\n      currentPromise: null\n    };\n    this.requestArgs = requestArgs;\n    this.spec = spec;\n    this.stripeResource = stripeResource;\n  }\n  async iterate(pageResult) {\n    if (!(pageResult && pageResult.data && typeof pageResult.data.length === 'number')) {\n      throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n    }\n    const reverseIteration = isReverseIteration(this.requestArgs);\n    if (this.index < pageResult.data.length) {\n      const idx = reverseIteration ? pageResult.data.length - 1 - this.index : this.index;\n      const value = pageResult.data[idx];\n      this.index += 1;\n      return {\n        value,\n        done: false\n      };\n    } else if (pageResult.has_more) {\n      // Reset counter, request next page, and recurse.\n      this.index = 0;\n      this.pagePromise = this.getNextPage(pageResult);\n      const nextPageResult = await this.pagePromise;\n      return this.iterate(nextPageResult);\n    }\n    return {\n      done: true,\n      value: undefined\n    };\n  }\n  /** @abstract */\n  getNextPage(_pageResult) {\n    throw new Error('Unimplemented');\n  }\n  async _next() {\n    return this.iterate(await this.pagePromise);\n  }\n  next() {\n    /**\n     * If a user calls `.next()` multiple times in parallel,\n     * return the same result until something has resolved\n     * to prevent page-turning race conditions.\n     */\n    if (this.promiseCache.currentPromise) {\n      return this.promiseCache.currentPromise;\n    }\n    const nextPromise = (async () => {\n      const ret = await this._next();\n      this.promiseCache.currentPromise = null;\n      return ret;\n    })();\n    this.promiseCache.currentPromise = nextPromise;\n    return nextPromise;\n  }\n}\nclass ListIterator extends StripeIterator {\n  getNextPage(pageResult) {\n    const reverseIteration = isReverseIteration(this.requestArgs);\n    const lastId = getLastId(pageResult, reverseIteration);\n    return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n      [reverseIteration ? 'ending_before' : 'starting_after']: lastId\n    });\n  }\n}\nclass SearchIterator extends StripeIterator {\n  getNextPage(pageResult) {\n    if (!pageResult.next_page) {\n      throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');\n    }\n    return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n      page: pageResult.next_page\n    });\n  }\n}\nconst makeAutoPaginationMethods = (stripeResource, requestArgs, spec, firstPagePromise) => {\n  if (spec.methodType === 'search') {\n    return makeAutoPaginationMethodsFromIterator(new SearchIterator(firstPagePromise, requestArgs, spec, stripeResource));\n  }\n  if (spec.methodType === 'list') {\n    return makeAutoPaginationMethodsFromIterator(new ListIterator(firstPagePromise, requestArgs, spec, stripeResource));\n  }\n  return null;\n};\nexports.makeAutoPaginationMethods = makeAutoPaginationMethods;\nconst makeAutoPaginationMethodsFromIterator = iterator => {\n  const autoPagingEach = makeAutoPagingEach(function () {\n    return iterator.next(...arguments);\n  });\n  const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n  const autoPaginationMethods = {\n    autoPagingEach,\n    autoPagingToArray,\n    // Async iterator functions:\n    next: () => iterator.next(),\n    return: () => {\n      // This is required for `break`.\n      return {};\n    },\n    [getAsyncIteratorSymbol()]: () => {\n      return autoPaginationMethods;\n    }\n  };\n  return autoPaginationMethods;\n};\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\nfunction getAsyncIteratorSymbol() {\n  if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n    return Symbol.asyncIterator;\n  }\n  // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n  return '@@asyncIterator';\n}\nfunction getDoneCallback(args) {\n  if (args.length < 2) {\n    return null;\n  }\n  const onDone = args[1];\n  if (typeof onDone !== 'function') {\n    throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);\n  }\n  return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n  if (args.length === 0) {\n    return undefined;\n  }\n  const onItem = args[0];\n  if (typeof onItem !== 'function') {\n    throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);\n  }\n  // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n  if (onItem.length === 2) {\n    return onItem;\n  }\n  if (onItem.length > 2) {\n    throw Error(`The \\`onItem\\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);\n  }\n  // This magically handles all three of these usecases (the latter two being functionally identical):\n  // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n  // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n  // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n  return function _onItem(item, next) {\n    const shouldContinue = onItem(item);\n    next(shouldContinue);\n  };\n}\nfunction getLastId(listResult, reverseIteration) {\n  const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n  const lastItem = listResult.data[lastIdx];\n  const lastId = lastItem && lastItem.id;\n  if (!lastId) {\n    throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n  }\n  return lastId;\n}\nfunction makeAutoPagingEach(asyncIteratorNext) {\n  return function autoPagingEach( /* onItem?, onDone? */\n  ) {\n    const args = [].slice.call(arguments);\n    const onItem = getItemCallback(args);\n    const onDone = getDoneCallback(args);\n    if (args.length > 2) {\n      throw Error(`autoPagingEach takes up to two arguments; received ${args}`);\n    }\n    const autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext,\n    // @ts-ignore we might need a null check\n    onItem);\n    return (0, utils_js_1.callbackifyPromiseWithTimeout)(autoPagePromise, onDone);\n  };\n}\nfunction makeAutoPagingToArray(autoPagingEach) {\n  return function autoPagingToArray(opts, onDone) {\n    const limit = opts && opts.limit;\n    if (!limit) {\n      throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');\n    }\n    if (limit > 10000) {\n      throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n    }\n    const promise = new Promise((resolve, reject) => {\n      const items = [];\n      autoPagingEach(item => {\n        items.push(item);\n        if (items.length >= limit) {\n          return false;\n        }\n      }).then(() => {\n        resolve(items);\n      }).catch(reject);\n    });\n    // @ts-ignore\n    return (0, utils_js_1.callbackifyPromiseWithTimeout)(promise, onDone);\n  };\n}\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n  return new Promise((resolve, reject) => {\n    function handleIteration(iterResult) {\n      if (iterResult.done) {\n        resolve();\n        return;\n      }\n      const item = iterResult.value;\n      return new Promise(next => {\n        // Bit confusing, perhaps; we pass a `resolve` fn\n        // to the user, so they can decide when and if to continue.\n        // They can return false, or a promise which resolves to false, to break.\n        onItem(item, next);\n      }).then(shouldContinue => {\n        if (shouldContinue === false) {\n          return handleIteration({\n            done: true,\n            value: undefined\n          });\n        } else {\n          return asyncIteratorNext().then(handleIteration);\n        }\n      });\n    }\n    asyncIteratorNext().then(handleIteration).catch(reject);\n  });\n}\nfunction isReverseIteration(requestArgs) {\n  const args = [].slice.call(requestArgs);\n  const dataFromArgs = (0, utils_js_1.getDataFromArgs)(args);\n  return !!dataFromArgs.ending_before;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","makeAutoPaginationMethods","utils_js_1","require","StripeIterator","constructor","firstPagePromise","requestArgs","spec","stripeResource","index","pagePromise","promiseCache","currentPromise","iterate","pageResult","data","length","Error","reverseIteration","isReverseIteration","idx","done","has_more","getNextPage","nextPageResult","undefined","_pageResult","_next","next","nextPromise","ret","ListIterator","lastId","getLastId","_makeRequest","SearchIterator","next_page","page","methodType","makeAutoPaginationMethodsFromIterator","iterator","autoPagingEach","makeAutoPagingEach","arguments","autoPagingToArray","makeAutoPagingToArray","autoPaginationMethods","return","getAsyncIteratorSymbol","Symbol","asyncIterator","getDoneCallback","args","onDone","getItemCallback","onItem","_onItem","item","shouldContinue","listResult","lastIdx","lastItem","id","asyncIteratorNext","slice","call","autoPagePromise","wrapAsyncIteratorWithCallback","callbackifyPromiseWithTimeout","opts","limit","promise","Promise","resolve","reject","items","push","then","catch","handleIteration","iterResult","dataFromArgs","getDataFromArgs","ending_before"],"sources":["C:/Users/Marcia/OneDrive/Escritorio/Web-dev/Working/Ecommerce-2023/client/node_modules/stripe/cjs/autoPagination.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeAutoPaginationMethods = void 0;\nconst utils_js_1 = require(\"./utils.js\");\nclass StripeIterator {\n    constructor(firstPagePromise, requestArgs, spec, stripeResource) {\n        this.index = 0;\n        this.pagePromise = firstPagePromise;\n        this.promiseCache = { currentPromise: null };\n        this.requestArgs = requestArgs;\n        this.spec = spec;\n        this.stripeResource = stripeResource;\n    }\n    async iterate(pageResult) {\n        if (!(pageResult &&\n            pageResult.data &&\n            typeof pageResult.data.length === 'number')) {\n            throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n        }\n        const reverseIteration = isReverseIteration(this.requestArgs);\n        if (this.index < pageResult.data.length) {\n            const idx = reverseIteration\n                ? pageResult.data.length - 1 - this.index\n                : this.index;\n            const value = pageResult.data[idx];\n            this.index += 1;\n            return { value, done: false };\n        }\n        else if (pageResult.has_more) {\n            // Reset counter, request next page, and recurse.\n            this.index = 0;\n            this.pagePromise = this.getNextPage(pageResult);\n            const nextPageResult = await this.pagePromise;\n            return this.iterate(nextPageResult);\n        }\n        return { done: true, value: undefined };\n    }\n    /** @abstract */\n    getNextPage(_pageResult) {\n        throw new Error('Unimplemented');\n    }\n    async _next() {\n        return this.iterate(await this.pagePromise);\n    }\n    next() {\n        /**\n         * If a user calls `.next()` multiple times in parallel,\n         * return the same result until something has resolved\n         * to prevent page-turning race conditions.\n         */\n        if (this.promiseCache.currentPromise) {\n            return this.promiseCache.currentPromise;\n        }\n        const nextPromise = (async () => {\n            const ret = await this._next();\n            this.promiseCache.currentPromise = null;\n            return ret;\n        })();\n        this.promiseCache.currentPromise = nextPromise;\n        return nextPromise;\n    }\n}\nclass ListIterator extends StripeIterator {\n    getNextPage(pageResult) {\n        const reverseIteration = isReverseIteration(this.requestArgs);\n        const lastId = getLastId(pageResult, reverseIteration);\n        return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n            [reverseIteration ? 'ending_before' : 'starting_after']: lastId,\n        });\n    }\n}\nclass SearchIterator extends StripeIterator {\n    getNextPage(pageResult) {\n        if (!pageResult.next_page) {\n            throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');\n        }\n        return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n            page: pageResult.next_page,\n        });\n    }\n}\nconst makeAutoPaginationMethods = (stripeResource, requestArgs, spec, firstPagePromise) => {\n    if (spec.methodType === 'search') {\n        return makeAutoPaginationMethodsFromIterator(new SearchIterator(firstPagePromise, requestArgs, spec, stripeResource));\n    }\n    if (spec.methodType === 'list') {\n        return makeAutoPaginationMethodsFromIterator(new ListIterator(firstPagePromise, requestArgs, spec, stripeResource));\n    }\n    return null;\n};\nexports.makeAutoPaginationMethods = makeAutoPaginationMethods;\nconst makeAutoPaginationMethodsFromIterator = (iterator) => {\n    const autoPagingEach = makeAutoPagingEach((...args) => iterator.next(...args));\n    const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n    const autoPaginationMethods = {\n        autoPagingEach,\n        autoPagingToArray,\n        // Async iterator functions:\n        next: () => iterator.next(),\n        return: () => {\n            // This is required for `break`.\n            return {};\n        },\n        [getAsyncIteratorSymbol()]: () => {\n            return autoPaginationMethods;\n        },\n    };\n    return autoPaginationMethods;\n};\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\nfunction getAsyncIteratorSymbol() {\n    if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n        return Symbol.asyncIterator;\n    }\n    // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n    return '@@asyncIterator';\n}\nfunction getDoneCallback(args) {\n    if (args.length < 2) {\n        return null;\n    }\n    const onDone = args[1];\n    if (typeof onDone !== 'function') {\n        throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);\n    }\n    return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n    if (args.length === 0) {\n        return undefined;\n    }\n    const onItem = args[0];\n    if (typeof onItem !== 'function') {\n        throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);\n    }\n    // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n    if (onItem.length === 2) {\n        return onItem;\n    }\n    if (onItem.length > 2) {\n        throw Error(`The \\`onItem\\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);\n    }\n    // This magically handles all three of these usecases (the latter two being functionally identical):\n    // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n    // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n    // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n    return function _onItem(item, next) {\n        const shouldContinue = onItem(item);\n        next(shouldContinue);\n    };\n}\nfunction getLastId(listResult, reverseIteration) {\n    const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n    const lastItem = listResult.data[lastIdx];\n    const lastId = lastItem && lastItem.id;\n    if (!lastId) {\n        throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n    }\n    return lastId;\n}\nfunction makeAutoPagingEach(asyncIteratorNext) {\n    return function autoPagingEach( /* onItem?, onDone? */) {\n        const args = [].slice.call(arguments);\n        const onItem = getItemCallback(args);\n        const onDone = getDoneCallback(args);\n        if (args.length > 2) {\n            throw Error(`autoPagingEach takes up to two arguments; received ${args}`);\n        }\n        const autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext, \n        // @ts-ignore we might need a null check\n        onItem);\n        return (0, utils_js_1.callbackifyPromiseWithTimeout)(autoPagePromise, onDone);\n    };\n}\nfunction makeAutoPagingToArray(autoPagingEach) {\n    return function autoPagingToArray(opts, onDone) {\n        const limit = opts && opts.limit;\n        if (!limit) {\n            throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');\n        }\n        if (limit > 10000) {\n            throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n        }\n        const promise = new Promise((resolve, reject) => {\n            const items = [];\n            autoPagingEach((item) => {\n                items.push(item);\n                if (items.length >= limit) {\n                    return false;\n                }\n            })\n                .then(() => {\n                resolve(items);\n            })\n                .catch(reject);\n        });\n        // @ts-ignore\n        return (0, utils_js_1.callbackifyPromiseWithTimeout)(promise, onDone);\n    };\n}\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n    return new Promise((resolve, reject) => {\n        function handleIteration(iterResult) {\n            if (iterResult.done) {\n                resolve();\n                return;\n            }\n            const item = iterResult.value;\n            return new Promise((next) => {\n                // Bit confusing, perhaps; we pass a `resolve` fn\n                // to the user, so they can decide when and if to continue.\n                // They can return false, or a promise which resolves to false, to break.\n                onItem(item, next);\n            }).then((shouldContinue) => {\n                if (shouldContinue === false) {\n                    return handleIteration({ done: true, value: undefined });\n                }\n                else {\n                    return asyncIteratorNext().then(handleIteration);\n                }\n            });\n        }\n        asyncIteratorNext()\n            .then(handleIteration)\n            .catch(reject);\n    });\n}\nfunction isReverseIteration(requestArgs) {\n    const args = [].slice.call(requestArgs);\n    const dataFromArgs = (0, utils_js_1.getDataFromArgs)(args);\n    return !!dataFromArgs.ending_before;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}